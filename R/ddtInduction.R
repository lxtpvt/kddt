# =========================================================================================================
# KDDT induction functions
# =========================================================================================================

# Fit a large number of stumps
stumps <- function(dX, nSim, fitedModel, predMethod, samplingStrategies, rpartParas, rm_seed, ncores) {
  # check the maxdepth parameter in rpart.control to keep maxdepth = 1
  if (rpartParas$control$maxdepth != 1) {
    return("The maxdepth parameter should be set to 1!")
  }
  # number of samplingStrategies
  nStrategies <- length(samplingStrategies)
  # the names of covariates
  samplingStrategies[[1]]$samplingRegion$data_range$names -> namesCov

  spT <- list()

  for (j in 1:nStrategies) {
    for (i in 1:nSim) {
      samplingStrategies[[j]]$seed = rm_seed * i * j
      X <- do.call(
        samplingStrategies[[j]]$samplingMethod,
        list(samplingStrategies[[j]], dX)
      )
      y <- do.call(predMethod, list(fitedModel, X))
      df <- data.frame(X, y)
      stump <- rpart(y ~ ., data = df, method = rpartParas$method, control = rpartParas$control)
      spT <- append(spT, list(stump))
    }
  }
  stumpsList = list(stump_list = spT, samplingStrategies = samplingStrategies)
  return(stumpsList)
}

# Fit a large number of stumps, parallel version
stumpsParallel <- function(dX, nSim, fitedModel, predMethod, samplingStrategies, rpartParas, rm_seed, ncores) {
  func_list <- c(
    "dataRange", "rangeConditions", "samplingRegion",
    "randomSampling", "pcaSamplingContinuous", "pcaSamplingSizeOne", "marginalRandomSampling"
  )
  registerDoParallel(makeForkCluster(ncores))
  # check the maxdepth parameter in rpart.control to keep maxdepth = 1
  if (rpartParas$control$maxdepth != 1) {
    return("The maxdepth parameter should be set to 1!")
  }

  # number of samplingStrategies
  nStrategies <- length(samplingStrategies)

  spT <- list()
  for (j in 1:nStrategies) {
    temp_spT <- foreach(
      i = 1:nSim, .export = func_list,
      .packages = c("randomForest", "rpart")
    ) %dopar% {
      samplingStrategies[[j]]$seed = rm_seed * i * j
      X <- do.call(
        samplingStrategies[[j]]$samplingMethod,
        list(samplingStrategies[[j]], dX)
      )
      y <- do.call(predMethod, list(fitedModel, X))
      df <- data.frame(X, y)
      stump <- rpart(y ~ ., data = df, method = rpartParas$method, control = rpartParas$control)
    }
    spT <- append(spT, temp_spT)
  }
  stumpsList = list(stump_list = spT, samplingStrategies = samplingStrategies)
  return(stumpsList)
}


#' birth two nodes from one bottom node (@nid) of the @tree
#' @param nid a integer denotes the bottom node id.
#' @param X a dateframe includes the obsercations of covariates.
#' @param tree a tree (rpart object) includes the @nid bottom node.
#' @param fitedModel the fitted teacher model.
#' @param predMethod the predict function of the teacher model.
#' @param stumpFun a string equal to the name of stump functions. There are two of them, "stumps" and "stumpsParallel".
#' @param samplingParameters a list includes the sampling method name, sample size for interpretable and predictive trees and seed.
#' @param rpartParas a list includes the parameters of the rpart function for fitting the stump.
#' @param nSim a integer denotes the number of simulations.
#' @param ncores a integer denotes the number of CUP cores used in computation.
#'
#' @return a tree after birth.
#' @export
#'
# here, nid > 2
birth <- function(nid, X, tree, fitedModel, predMethod, stumpFun, samplingParameters, rpartParas, nSim, ncores=1) {
  if(!(nid %in% as.integer(row.names(tree$frame[tree$frame$var=="<leaf>",])))){
    print("The node is not a bottom node!")
    return()
  }
  X_range = dataRange(X)
  samplingRegion(nid, X_range, treeInfo(tree)) -> sR
  # print(sR$id_range)
  # set root sampling strategies
  stg = setSamplingStrategy(samplingRegion=sR, samplingParameters=samplingParameters, is.interpretable=T)
  samplingStrategies <- list(stg)
  # run simulation
  rm_seed = samplingParameters$seed
  stumpsRes <- do.call(stumpFun, list(X, nSim, fitedModel, predMethod, samplingStrategies, rpartParas, rm_seed, ncores))
  stump = createStump(stumpsRes,X_range)
  tree = insertStump(nid,stump,tree,X)
  # return the new tree
  #return(stumpsRes)
  return(tree)
}

#' The induction of interpretable nodes.
#' @param nids a vector includes a set of node ids, a binary tree can be generated by automatically filling the missing nodes.
#' @param type a strings in the vector of c("classification","regression","survival").
#' @param X a dateframe includes the obsercations of covariates.
#' @param fitedModel the fitted teacher model.
#' @param predMethod the predict function of the teacher model.
#' @param samplingParameters a list includes the sampling method name, sample size for interpretable and predictive trees and seed.
#' @param nSim a integer denotes the number of simulations.
#' @param ncores a integer denotes the number of CUP cores used in computation.
#'
#' @return a tree includes all interpretable nodes.
#' @export
#'
inductionInterpretableTree <- function(nids, type, X, fitedModel, predMethod, samplingParameters,
                                       nSim, ncores = 1) {

  if(!(type %in% c("classification","regression","survival"))){
    return("Please select 'type' in the set (classification, regression, survival)")
  }

  #ctl.interpretable <- rpart.control(xval=15, minbucket=5, minsplit=10,  cp=0, maxdepth = 1)
  ctl.interpretable <- rpart.control(maxdepth = 1)
  #ctl.predictive <- rpart.control(xval=15, minbucket=5, minsplit=10,  cp=0, maxdepth = 10)
  ctl.predictive <- rpart.control()
  if(type %in% c('regression','survival')){
    rpartParas.interpretable = setRpartPara(method = "anova", control=ctl.interpretable, predict_type="vector")
    rpartParas.predictive = setRpartPara(method = "anova", control=ctl.predictive, predict_type="vector")
  }else{
    rpartParas.interpretable = setRpartPara(method = "class", control=ctl.interpretable, predict_type="class")
    rpartParas.predictive = setRpartPara(method = "class", control=ctl.predictive, predict_type="class")
  }

  if(ncores>1){
    stumpFun="stumpsParallel"
  }else{
    stumpFun="stumps"
  }

  # the interpretable node ids
  if(max(nids)==1){
    return("At least one node id greater than 1 !")
  }
  treeIds(nids)->treeIds
  X_range <- dataRange(X)
  #
  depth_first(remove_bottom_nodes(treeIds))->ordered_split_ids
  i <- 0
  n <- length(ordered_split_ids)
  print("Interpretable subtree induction...")
  for (nid in ordered_split_ids) {
    i = i + 1
    if(nid==1){
      # if it is root node, the simpling region is the data range
      sR = setSamplingRegion(X_range)
      # set root sampling strategies
      stg = setSamplingStrategy(samplingRegion=sR, samplingParameters=samplingParameters, is.interpretable=T)
      samplingStrategies <- list(stg)
      stumpsRes <- do.call(stumpFun, list(X, nSim, fitedModel, predMethod, samplingStrategies,
                                          rpartParas.interpretable, i, ncores))
      createStump(stumpsRes,X_range)->root
      tree <- insertStump(nid,root,NULL,X)
      if(type=='survival'){
        tree$survival.y <- do.call(predMethod, list(fitedModel, X))
      }
    }else{
      tree <- birth(nid, X, tree, fitedModel, predMethod, stumpFun, samplingParameters,
                    rpartParas.interpretable, nSim, ncores)
    }
    print(paste0(i, " out of ", n))
  }
  tree$rpartParas.interpretable = rpartParas.interpretable
  tree$rpartParas.predictive = rpartParas.predictive
  return(tree)
}

#
#' Induction the remaining subtrees for good prediction
#' @param X a dateframe includes the obsercations of covariates.
#' @param interpretableTree the tree includes all interpretable nodes.
#' @param fitedModel the fitted teacher model.
#' @param predMethod the predict function of the teacher model.
#' @param samplingParameters a list includes the sampling method name, sample size for interpretable and predictive trees and seed.
#' @return a list of subtrees and their ids, the roots are the bottom nodes of the interpretable tree.
#' @export
#'
inductionPredictionTree <- function(X, interpretableTree, fitedModel, predMethod, samplingParameters, rpart.cp = 0.00001) {

  where <- interpretableTree$where
  treeInfo <- treeInfo(interpretableTree)
  dR = dataRange(X)
  ids <- as.integer(row.names(interpretableTree$frame[interpretableTree$frame$var == "<leaf>", ]))
  n.total <- samplingParameters$sampleSize[2]
  trees <- list()
  print("Predictive subtrees induction...")
  i=1
  for (id in ids) {
    flag = FALSE
    sR <- samplingRegion(id, dR, treeInfo)
    if(length(samplingParameters$exploreNodes)>0){
      for (expNode in samplingParameters$exploreNodes) {
        if(id==expNode[1]){
          samplingParameters$sampleSize[2] <- expNode[2]
          flag = TRUE
        }
      }
    }else{
      samplingParameters$sampleSize[2] <- n.total*((sum(where==id)/length(where))+0.05)
      flag = TRUE
    }
    if(!flag){
      samplingParameters$sampleSize[2] <- n.total*((sum(where==id)/length(where))+0.05)
    }

    stg <- setSamplingStrategy(samplingRegion=sR, samplingParameters=samplingParameters, is.interpretable=F)
    ctl = interpretableTree$rpartParas.predictive$control
    ctl$cp = rpart.cp

    pX <- do.call(samplingParameters$samplingMethod, list(stg,X))
    py <- do.call(predMethod, list(fitedModel, pX))
    df <- data.frame(pX, py)
    tree <- rpart(py ~ ., data = df, method = interpretableTree$rpartParas.predictive$method, control = ctl)
    trees <- append(trees, list(tree))
    print(paste0(i, " out of ", length(ids)))
    i=i+1
  }
  return(list(ids = ids, trees = trees))
}

#' The induction of KDDT
#' @param nids a vector includes a set of node ids, a binary tree can be generated by automatically filling the missing nodes.
#' @param type a strings in the vector of c("classification","regression","survival").
#' @param X a dateframe includes the obsercations of covariates.
#' @param y a vector for regression or classification, NULL for survival.
#' @param fitedModel the fitted teacher model.
#' @param predMethod the predict function of the teacher model.
#' @param samplingParameters a list includes the sampling method name, sample size for interpretable and predictive trees and seed.
#' @param nSim a integer denotes the number of simulations.
#' @param ncores a integer denotes the number of CUP cores used in computation.
#'
#' @return a list includes the interpretable tree and a list of subtrees.
#' @export
#'
kddtInduction <- function(nids, type, X, y, fitedModel, predMethod, samplingParameters, nSim, rpart.cp = 0.00001, ncores = 1) {

  if(!(type %in% c("classification","regression","survival"))){
    return("Please select 'type' in the set (classification, regression, survival)")
  }

  interpretableTree <- inductionInterpretableTree(nids, type, X, fitedModel, predMethod,
                                                  samplingParameters, nSim, ncores = ncores)

  subTrees <- inductionPredictionTree(X, interpretableTree, fitedModel, predMethod, samplingParameters, rpart.cp)

  return(list(interpretableTree = interpretableTree, predictiveSubTrees = subTrees, data=list(X=X,y=y)))
}


#' The induction of KDDT
#' @param X a dateframe includes the obsercations of covariates.
#' @param y a vector for regression or classification, NULL for survival.
#' @param interpretableTree the fitted interpretable tree.
#' @param fitedModel the fitted teacher model.
#' @param predMethod the predict function of the teacher model.
#' @param samplingParameters a list includes the sampling method name, sample size for interpretable and predictive trees and seed.
#'
#' @return a list includes the interpretable tree and a list of subtrees.
#' @export
#'
kddtInductionFromInterpretable <- function(X, y, interpretableTree, fitedModel, predMethod, samplingParameters, rpart.cp = 0.00001) {

  subTrees <- inductionPredictionTree(X, interpretableTree, fitedModel, predMethod, samplingParameters, rpart.cp)
  #imp <- importance.ddt(y, X, interpretableTree, subTrees)
  return(list(interpretableTree = interpretableTree, predictiveSubTrees = subTrees, data=list(X=X,y=y)))
}

#
#' KDDT prediction function
#' @param kddtModel the fitted KDDT model.
#' @param newX a dateframe includes the obsercations of covariates.
#' @param predict_type character string, c("vector", "prob", "class", "matrix"), denoting the type of predicted value returned. If the rpart object is a classification tree, then the default is to return prob predictions, a matrix whose columns are the probability of the first, second, etc. class. (This agrees with the default behavior of tree). Otherwise, a vector result is returned.
#'
#' @return a vector includes the predicted response.
#' @export
#'
kddtPredict <- function(kddtModel, newX, predict_type) {

  if(!(predict_type %in% c("vector", "prob", "class", "matrix"))){
    return("Please provide correct type in (vector, prob, class, matrix)!")
  }
  newX_range <- dataRange(newX)
  n <- dim(newX)[1]
  y <- list()

  if(is.null(kddtModel$predictiveSubTrees)){
    # print("predictive Subtreee is null!")
    treeInfo = treeInfo(kddtModel)
    for (i in 1:n) {
      bid <- getDdtLeafNid(newX[i, ], treeInfo, newX_range)
      y_temp <- kddtModel$frame[which(treeInfo$nid==bid),"yval"]
      y <- append(y, list(y_temp))
    }
  }else{
    treeInfo = treeInfo(kddtModel$interpretableTree)
    for (i in 1:n) {
      bid <- getDdtLeafNid(newX[i, ], treeInfo, newX_range)
      t_index <- which(kddtModel$predictiveSubTrees$ids == bid)
      # print(c(bid,t_index))
      y_temp <- predict(object=kddtModel$predictiveSubTrees$trees[[t_index]], newdata=newX[i, ], type=predict_type)
      y <- append(y, list(y_temp))
    }
  }
  if(predict_type %in% c("vector", "class")){
    res = unlist(y)
  }else{
    res = y
  }
  return(res)
}
